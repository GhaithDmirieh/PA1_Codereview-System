\section{Grundlagen}
\label{sec:Grundlagen}

\subsection{Definition}
\label{subsec:Definition}

\begin{description}
	\item [Codereview:]
		Unter Codereview Versteht man, eine manuelle Überprüfung des Quellcodes durch andere Entwickler als den Autor. Es gilt als wertvolles Werkzeug zur Reduzierung von 							Softwarefehlern und zur Verbesserung der Qualität von Softwareprojekten \cite{bacchelli2013expectations}.

	\item [VCS:]
		"`Versionskontrollsysteme sind Softwaretools, mit deren Hilfe Softwareteams Quellcodeänderungen verwalten können. Die Versionskontrollsoftware verfolgt jede Änderung am Code und 		speichert sie in einer speziell hierfür angelegten Datenbank. Unterläuft einem Entwickler ein Fehler, kann er einen Schritt zurück machen, seinen Code mit früheren Codeversionen 		abgleichen und Korrekturen implementieren. Und das mit minimalen Beeinträchtigungen für seine Teamkollegen."' \cite{version-control-System}

	\item [Git:]
		Git ist eine freie und Open-Source Software zur Versionsverwaltung von Dateien, das 2005 ursprünglich von Linus Torvalds, dem berühmten Entwickler des Linux Betriebssystem-				Kernel, entwickelt wurde.
	
	\item [SVN:]
		Apache Subversion ist eine freie Software zur zentralen Versionsverwaltung von Dateien und Verzeichnissen. Die Versionierung erfolgt in einem zentralen Repository in Form einer  		Revisionszählung.
	\unsure{Git und SVN in Unterabschnitte von VSC, da sie Programme sind. vergleiche sie auch miteinander}
	
	\item [Post-commit:]
		Die Überprüfung erfolgt, nachdem die Änderungen am Quelltext an das Ziel-Repository gesendet wurde.
		\begin{description}
			\item [Vorteile:] \hfill
			\begin{enumerate}
				\item Andere Teammitglieder sehen die Codeänderungen und können ihre Arbeit entsprechend ändern
				\item Dieser Prozess kann praktisch sein, weil einige Änderungen komplex und lang sein können und mehrere Schritte für den Review erfordern
			\end{enumerate}
			
			\item[Nachteile:] \hfill
			\begin{enumerate}
				\item Erhöhte Wahrscheinlichkeit, dass schlechter Code in das Haupt Repository gelangt, was sich auf die Arbeit des gesamten Teams auswirkt
				\item Wenn Fehler gefunden werden, kann es eine Weile dauern, bis der Entwickler zu dem Modul zurückkehrt, an dem er gearbeitet hat
			\end{enumerate}
		\end{description}
		
		
	\item [pre-commit:]
		Ist eine Art des Reviews, mit der man die Änderungen des Quelltextes überprüft, bevor die in das Haupt-Repository des Versionsverwaltungssystem gelangen.
		\begin{description}
			\item [Vorteile:] \hfill
			\begin{enumerate}
				\item Diese Art erstellt eine Art von Sicherheit, da fehlerhafte oder unvollständige Änderungen durch den Review auftreten können
				\item Dieser Prozess stellt sicher, dass der Autor seine Änderungen überprüfen lässt und nicht direkt in das Ziel-Repository eincheckt
			\end{enumerate}
		\end{description}
		
	\item [Pull-Request:]
		Anfrage erstellen und an die Reviewer abschicken um Änderungen am Code zu überprüfen. Meistens arbeitet der Entwickler an einem Zweig vom master-branch und sobald er fertig ist 			sendet er die Pull-Request an die Review. Wird eine Pull-Request akzeptiert, so spricht man von einem Merge, wird er geschlossen, so spricht man von einem Close.
	
	\item [Continuous Integration(CI):]
		"`CI bedeutet Continuous Integration, also der Automatisierungsprozess für Entwickler. Bei einer erfolgreichen CI werden regelmäßig neue Codeänderungen für Apps entwickelt, 				geprüft und in einem gemeinsamen Repository zusammengeführt. Damit soll der Konflikt verhindert werden, den zu viele Branches einer App verursachen können, wenn sie zeitgleich 			entwickelt werden."' \cite{RedHat}
			
	\item [Continuous Delivery (CD):]
		"`Continuous Delivery bedeutet üblicherweise, dass App Änderungen eines Entwicklers automatisch auf Bugs getestet und in ein Repository (wie GitHub oder eine Container 					Registry) hochgeladen werden, von wo aus sie vom Operations-Team in einer Live-Produktivumgebung bereitgestellt werden können. Dieser Vorgang ist die Antwort auf Transparenz- 				und Kommunikationsprobleme zwischen Dev- und Business-Teams. Damit soll sichergestellt werden, dass neuer Code mit minimalem Aufwand implementiert werden kann."' \cite{RedHat}
		
	\item [Continuous Deployment(CD):]
		"`Continuous Deployment (das andere „CD“) kann sich auf die automatische Freigabe von Entwickleränderungen vom Repository zur Produktivphase beziehen, wo sie direkt vom Kunden 			genutzt werden können. Dieser Vorgang soll der Überlastung von Operations-Teams bei manuellen Prozessen entgegenwirken, die die Anwendungsbereitstellung verlangsamen. Continuous 		Development baut die Vorteile der Continuous Delivery aus, indem auch noch die nächste Phase der Pipeline automatisiert wird."' \cite{RedHat}

	Dieser Prozess kann als eine Pipeline vorgestellt werden, die die \cref{fig:RedHat} beschreibt.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\textwidth]{Red Hat CI CD}
		\caption[\ac{CI}/\ac{CD}]{\ac{CI}/\ac{CD} Prozess als Pipeline\\ \cite{RedHat}}
		\label{fig:RedHat}
	\end{figure}
	
\end{description}

\subsection{Motivation}
\label{subsec:Gründe}
Durch den Review des Codes bestehen zahlreiche Vorteile. Davon sind:

\begin{enumerate}
	\item Das Vermeiden von Fehlern im Quellcode, denn es ist immer sehr umständlich, wenn erst nach einer Weile einen Fehler auftritt, was eine ältere Änderung verursachte.
		Fehler müssen nicht nur, diejenige die das Programm nicht mehr zum Laufen bringen. Die können auch Falsche Schnittstellenspezifikation oder Verletzung von Namenskonventione 
		etc.\ sein.
	\item Fehler die erst beim Kunden auftreten, weil vorher keiner drüber geguckt hat kosten Geld und Reputation.
	\item Die Reviewer können durch lesen der Änderungen lernen.
	\item Der Autor kann durch Review-Kommentare lernen.
	\item Verbesserungsvorschläge und vielmehr.
\end{enumerate}

\unsure{Reicht das ?}

\subsection{Vorgehensmethoden}
\label{subsec:Vorgehensmethoden}
Es gibt verschiedene Verfahren von Reviews. Die am häufigsten benutzte Verfahren sind:

\begin{itemize}
	\item Ad-hoc: Der Review passiert nur für einen bestimmten Zweck und ist nicht zuvor geplant.
	\item Over–the–shoulder: Der Autor setzt direkt neben dem Reviewer, der die Änderungen kritisiert. Dieses Verfahren ist eine informelle Review.
	\item Email pass-around: Der Autor sendet eine E-Mail mit dem Code zur Überprüfung des Codes an die Reviewer.
	\item Tool-assisted: auch \ac{CRS}. Hier werden Tools benutzt, die die Änderungen je nach Einstellung des Systems an die Rezensenten zum Überprüfen weiterleiten.
	\item Reviewsitzung: Das Team trefft sich regelmäßig, je nach Absprache. Diverse Meinungen werden dargestellt.
	\item Stand Up Meeting: Am Ende des Tages werden die Änderungen diskutiert. Das Team muss nicht unbedingt dabei sein, sondern nur die für die Änderungen zuständig sind.
	\item Planung: Entwickler werden zur Review eingeladen, rollen werden verteilt und die Bedingungen werden festgelegt.
\end{itemize}

\textbf{Nachteile der Methoden die nicht Tool-basiert sind:}
\begin{itemize}
	\item Die Änderungen werden zuerst im Quellcode geschrieben, was Fehler enthalten kann und danach kommt die Review.
	\item Dieser Prozess ist nicht flexibel, denn es fordert die Anwesenheit der für die Änderungen zuständige Personen zusammen mit den Rezensenten.
	\item Es wird für den Review keine Dokumentation erstellt.
\end{itemize}

\subsection{Mögliche Git-Workflows}
\label{sec:Git-Workflows}

Git bietet die Möglichkeit, den Workflow an den Bedürfnisse des Teams anzupassen, daher gibt es unterschiedliche Workflows.
Die Workflows:
\begin{itemize}
	\item Feature-Branch-Workflow
	\item Git-flow-Workflow
\end{itemize}
werden hier vorgestellt.

\subsubsection{Feature-Branch-Workflow}
\label{subsubsec:Feature-Branch-Workflow}

Ziel dieses Workflows, dass ein anderes Branch statt dem Master-Branch (Haupt-Branch) für die Entwicklung von Features und die Review verwendet.
Ablauf: Vom Master-Branch wird einen Zweig erstellt, den der Entwickler zu seiner Arbeitskopie klont. So arbeitet er unabhängig von seinen Kollegen an einem bestimmten Feature und 		sobald er das Feature fertig hat, wird er seine Änderungen mit einem \code{push} in dem abgespaltenen Branch senden. Danach kann der Entwickler je nach Einstellungen des Systems den 	Review starten. Wird der Review z. B. mit einer Pull-Request gemacht werden, soll der Entwickler an dieser Stelle die Pull-Anfrage starten. So können sich die Reviewer die 				Änderungen anschauen, kommentieren und mit dem Autor diskutieren und am Ende diese Änderungen entweder annehmen oder ablehnen. Werden diese Änderungen angenommen, können direkt in 		das Master-Branch zusammengeführt werden \cite{Feature-Branch-Workflow}. Die \cref{fig:Forking-workflow} verdeutlicht diesen Prozess. 

\textbf{Eigenschaften dieses Verfahrens:}
\begin{itemize}
	\item Entwickler arbeiten nicht direkt an dem Haupt-Branch, demzufolge stören sie einander nicht
	\item Jedes Feature ist in einem Feature-Branch gekapselt
\end{itemize}

\subsubsection{Git-flow-Workflow}
\label{subsubsec:Git-flow-Workflow}

"`Der Git-flow-Workflow ist ein Git-Workflow, der von Vincent Driessen auf nvie veröffentlicht und bekannt gemacht wurde. Der Git-flow-Workflow definiert ein strenges Branching-Modell, das um den Release des Projekts konzipiert wurde. Dies bietet einen robusten Rahmen für das Management größerer Projekte.
Git-flow ist hervorragend für Projekte mit einem Release-Zyklus nach Zeitplan geeignet. Mit diesem Workflow werden keine neuen Konzepte oder Befehle hinzugefügt, die nicht auch für 		den Feature-Branch-Workflow erforderlich sind. Stattdessen werden verschiedenen Branches sehr spezifische Rollen zugewiesen, und es wird genau festgelegt, wann und wie die 				Interaktion erfolgen soll. Zusätzlich zu feature-Branches werden einzelne Branches zum Vorbereiten, Warten und Erfassen von Releases verwendet. Dabei kannst du natürlich auch alle 		Vorteile von Feature-Branch-Workflows nutzen: Pull-Anfragen, isolierte Tests und eine effizientere Zusammenarbeit."' \cite{Git-flow-Workflow}

Hier wird also ein anderes Branch (develp-Branch) zusätzlich zum Master-Branch betrachtet. Dieses Branch wird für die Entwicklung verantwortlich sein, indem auf dem Master-Branch 			nur die Versionen zu sehen sind. Die Features werden in abgespaltenen Branchs vom Develop-Branch entwickelt und mit dem develop-Branch nach einer erfolgreichem Pull-Anfrage 				zusammengeführt werden. Sind die Features auf dem develop-Branch soweit für eine neue Version, wird ein Release-Branch vom dvelop-Branch abgespalten, mit dem Release-Branch keine 			Features mehr von anderen Branchs zusammengeführt werden. Dieses Branch sagt einfach "Ich bin die neue Version". Falls das Release-Branch Fehler enthält, kann die Behebung dieser			Fehler wieder in einem anderen Branch geschehen und in das Release-Branch zusammengeführt werden. Funktioniert die Version einwandfrei, wird sie mit dem Master-Branch 						zusammengeführt. Die \cref{fig:Git-flow-Workflow} soll bei der Vorstellung von diesem Workflow helfen.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{Git-flow-Workflow}
	\caption[Git-flow-Workflow]{Git-flow-Workflow.\\ \cite{Git-flow-Workflow}}
	\label{fig:Git-flow-Workflow}
\end{figure}
	
\textbf{Eigenschaften dieses Verfahrens:}
\begin{itemize}
	\item Dieser Workflow hat alle Eigenschaften des letzten Workflows im \ref{subsubsec:Feature-Branch-Workflow}
	\item Eignet sich gut für große Projekte, die mehrere Versionen enthalten sollen
	\item Dank des Develop-Branchs und der Release-Branchs hat das Master-Branch eine saubere Historie, da es auf dem Develop-Branchs statt dem Master-Branch entwickelt wird
\end{itemize}

